// The problem_factory module is a class implementing a classic factory pattern
// to instantiate problem solutions
pub mod problem_factory {

    // get_solution is the factory method for creating a solution to each problem
    pub fn get_solution(problem_number: i32) -> String {
        match problem_number {
            1 => super::multiple_3or5::compute(),
            2 => super::even_fibonacci::compute(),
            3 => super::largest_prime_factor::compute(),
            4 => super::largest_palindrome_product::compute(),
            5 => super::smallest_multiple::compute(),
            6 => super::sum_square_difference::compute(),
            7 => super::prime10001::compute(),
            8 => super::largest_product_series::compute(),
            9 => super::pythagorean_triplet::compute(),
            10 => super::summation_primes::compute(),
            11 => super::largest_product_grid::compute(),
            _ => "Problem ".to_owned() + &problem_number.to_string() + " is not solved.",
        }
    }
    
}

pub mod largest_product_series {

    pub fn compute() -> String {

        let mut result: u64 = 0;
        let size_of_series: u64 = 13;

        let numbers_from_site: String = "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311330358907296290491560440772390713810515859307960866701724271218839987979087922749219016997208880937766572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224137565705605749026140797296865241453510047482166370484403199890008895243450658541227588666881178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450".to_string();
        let mut numbers: Vec<u64> = Vec::new();
        for index in 0..numbers_from_site.len() {
            let digit: String = numbers_from_site[index..index + 1].to_string();
            let digit: u64 = match digit.trim().parse() {
                Ok(num) => num,
                Err(_) => 1,      // If the input is invalid, just run problem number 1.
            };            
            numbers.push(digit); 
        }
        for range_start in 0..(numbers_from_site.len() - size_of_series as usize) {
            let series_of_numbers: Vec<u64> = numbers[(range_start as usize)..(range_start + size_of_series as usize)].to_vec();
            let trial = ::euler_library::math_library::series_product(series_of_numbers);
            result = if trial > result { trial } else { result }
        }
        result.to_string()

    }

}

/// <summary>
/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/// Find the sum of all the multiples of 3 or 5 below 1000.
/// </summary>
/// <returns>return the answer to the problem</returns>
pub mod multiple_3or5 {

    pub fn compute() -> String {
        let range_size : u64 = 1000 - 1;
        let sum_3s = ::euler_library::math_library::arithmetic_progression(range_size / 3, 3, 3);
        let sum_5s = ::euler_library::math_library::arithmetic_progression(range_size / 5, 5, 5);
        let sum_15s = ::euler_library::math_library::arithmetic_progression(range_size / 15, 15, 15);
        let result = sum_3s + sum_5s - sum_15s;
        result.to_string()
    }

}

/// <summary>
/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
/// By starting with 1 and 2, the first 10 terms will be:
///     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
/// find the sum of the even-valued terms.
/// </summary>
/// <returns></returns>
pub mod even_fibonacci {

    pub fn compute() -> String {
        let mut result = 2;
        let mut term1 = 1;
        let mut term2 = 2;

        let mut sum = term1 + term2;
        while sum < 4000000 {
            if ::euler_library::math_library::is_multiple(sum, 2) { result = result + sum; }
            term1 = term2;
            term2 = sum;
            sum = term1 + term2;
        };

        result.to_string()
    }

}

/// <summary>
/// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
/// Find the largest palindrome made from the product of two 3-digit numbers
/// </summary>
/// <returns></returns>
pub mod largest_palindrome_product {
    pub fn compute() -> String {
        let mut result: u64 = 0;
        for number1 in 100..1000 {
            for number2 in number1..1000 {
                let product: u64 = number1 * number2;
                let string_version = product.to_string();
                if &string_version[0..1] == &string_version[string_version.chars().count()-1..] {
                    if ::euler_library::math_library::reverse_digits(product) == product && product > result {
                        result = product;
                    }
                }
            }
        }
        result.to_string()
    }
}

/// <summary>
/// The prime factors of 13195 are 5, 7, 13 and 29.
/// What is the largest prime factor of the number 600,851,475,143?
/// </summary>
/// <returns></returns>
pub mod largest_prime_factor {
    pub fn compute() -> String {
        let value = 600851475143;
        let factors: Vec<u64> = ::euler_library::math_library::get_factors_with(value, ::euler_library::math_library::get_prime(10000));
        let result = factors[factors.len() - 1]; 
        result.to_string()
    }
}

///
/// 10,0001th Prime number
/// 
pub mod prime10001 {
    pub fn compute() -> String {
        let prime_numbers = ::euler_library::math_library::get_prime(110000);
        let result: u64 = prime_numbers[10001 - 1];
        result.to_string()
    }
}

/// <summary>
/// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
/// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
/// </summary>
/// <returns></returns>
pub mod smallest_multiple {
    pub fn compute() -> String {

        fn all_are_factors(n: u64, trial: u64) -> bool {
            if n == 1 { true }
            else if !(::euler_library::math_library::is_multiple(trial, n)) { false }
            else { all_are_factors(n - 1, trial) }
        }

        fn find_solution(n: u64, trial: u64) -> u64 {
            let mut result = trial;
            while !all_are_factors(n, result) { result = result + trial }
            result
        }

        let n: u64 = 30;
        let primes = ::euler_library::math_library::get_prime(n);
        let mut gap = 1;
        for prime in primes { gap = gap * prime; }
        let result = find_solution(n, gap);
        result.to_string()
    }
}

pub mod sum_square_difference{
    pub fn compute() -> String {
        (::euler_library::math_library::square(::euler_library::math_library::sum_natural(100)) - ::euler_library::math_library::sum_natural_squares(100)).to_string()
    }
}

/// <summary>
/// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
/// a^2 + b^2 = c^2
/// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
/// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
/// Find the product abc.
/// </summary>
/// <returns></returns>
pub mod pythagorean_triplet{
    pub fn compute() -> String {
        
        for a in 1 .. 334 {
            let mut done: bool = false;
            let mut b: u64 = a + 1;
            while !done {
                let c: u64 = 1000 - (a + b);
                if ::euler_library::math_library::square(a) + ::euler_library::math_library::square(b) == ::euler_library::math_library::square(c) {
                    return (a * b * c).to_string();
                }
                b += 1;
                if b >= c { done = true }
            }
        }

        "No result found".to_string()
    }
}

/// <summary>
/// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
/// Find the sum of all the primes below two million.
/// </summary>
/// <returns></returns>
pub mod summation_primes{
    pub fn compute() -> String {
        let prime_numbers: Vec<u64> = ::euler_library::math_library::get_prime(2000000);
        (::euler_library::math_library::series_sum(prime_numbers)).to_string()
    }
}

/// <summary>
/// In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
/// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
/// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
/// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
/// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
/// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
/// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
/// 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
/// 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
/// 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
/// 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
/// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
/// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
/// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
/// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
/// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
/// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
/// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
/// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
/// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
/// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
/// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
/// What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
/// </summary>
/// <returns></returns>
pub mod largest_product_grid {
    pub fn compute() -> String {
        let series_size: u32 = 4;
        let mut result: u64 = 0;
        let matrix: [[u64; 20]; 20] =
        [
            [08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
            [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],
            [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],
            [52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],
            [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
            [24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
            [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
            [67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],
            [24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
            [21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],
            [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],
            [16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],
            [86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
            [19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],
            [04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
            [88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
            [04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],
            [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],
            [20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],
            [01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]
     ];  
        
        for vertical in 0..20 {
            for horizontal in 0..20 {

                let v: usize = vertical as usize;
                let h: usize = horizontal as usize;

                if horizontal < 20 - series_size
                {
                    let trial: u64 = matrix[v][h] * matrix[v][h + 1] * matrix[v][h + 2] * matrix[v][h + 3];
                    if trial > result { result = trial; }
                }

                if vertical < 20 - series_size
                {
                    let trial: u64 = matrix[v][h] * matrix[v + 1][h] * matrix[v + 2][h] * matrix[v + 3][h];
                    if trial > result { result = trial; }
                }

                if (vertical < 20 - series_size) & (horizontal < 20 - series_size)
                {
                    let trial: u64 = matrix[v + 3][h] * matrix[v + 2][h + 1] * matrix[v + 1][h + 2] * matrix[v][h + 3];
                    if trial > result { result = trial; }
                }

                if (vertical < 20 - series_size) & (horizontal < 20 - series_size)
                {
                    let trial: u64 = matrix[v][h] * matrix[v + 1][h + 1] * matrix[v + 2][h + 2] * matrix[v + 3][h + 3];
                    if trial > result { result = trial; }
                }
                
            }
        }

        result.to_string()
    }
}