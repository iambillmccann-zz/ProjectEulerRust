use crate::euler_library::math_library::*;

pub trait IEulerSolution {
    fn compute(&self, problem_number: i32) -> String;
}

// The problem_factory module is a class implementing a classic factory pattern
// to instantiate problem solutions
pub mod problem_factory {

    use euler_library::problems::IEulerSolution;

    // get_solution is the factory method for creating a solution to each problem
    pub fn get_solution(problem_number: i32) -> String {

        match problem_number {
            1 => super::Mulitple3or5.compute(),
            2 => super::even_fibonacci::compute(),
            3 => super::largest_prime_factor::compute(),
            4 => super::largest_palindrome_product::compute(),
            5 => super::smallest_multiple::compute(),
            6 => super::sum_square_difference::compute(),
            7 => super::prime10001::compute(),
            8 => super::largest_product_series::compute(),
            _ => "Problem ".to_owned() + &problem_number.to_string() + " is not solved.",
        }
    }
    
}

pub struct GenericSolution;
impl IEulerSolution for GenericSolution {
    fn compute (&self, problem_number: i32) -> String { "Problem ".to_owned() + &problem_number.to_string() + " is not solved." }
}

/// <summary>
/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/// Find the sum of all the multiples of 3 or 5 below 1000.
/// </summary>
/// <returns>return the answer to the problem</returns>
pub struct Mulitple3or5;
impl Mulitple3or5 {

    pub fn brute_force() -> String {
        let mut result: u64 = 0;
        for number in 1..1000 {
            result = result + if is_multiple(number, 3) {
                number
            } else if is_multiple(number, 5) { 
                number
            } else { 0 };
        }
        result.to_string()
    }

}

impl IEulerSolution for Mulitple3or5 {

    fn compute(&self, problem_number: i32) -> String {
        let sum_3s = arithmetic_progression(999/3, 3, 3);
        let sum_5s = arithmetic_progression(999/5, 5, 5);
        let sum_15s = arithmetic_progression(999/15, 15, 15);
        let result = sum_3s + sum_5s - sum_15s;
        result.to_string()
    }

}

pub mod largest_product_series {

    pub fn compute() -> String {

        let mut result: u64 = 0;
        let size_of_series: u64 = 13;

        let numbers_from_site: String = "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311330358907296290491560440772390713810515859307960866701724271218839987979087922749219016997208880937766572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224137565705605749026140797296865241453510047482166370484403199890008895243450658541227588666881178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450".to_string();
        let mut numbers: Vec<u64> = Vec::new();
        for index in 0..numbers_from_site.len() {
            let digit: String = numbers_from_site[index..index + 1].to_string();
            let digit: u64 = match digit.trim().parse() {
                Ok(num) => num,
                Err(_) => 1,      // If the input is invalid, just run problem number 1.
            };            
            numbers.push(digit); 
        }
        for range_start in 0..(numbers_from_site.len() - size_of_series as usize) {
            let series_of_numbers: Vec<u64> = numbers[(range_start as usize)..(range_start + size_of_series as usize)].to_vec();
            let trial = ::euler_library::math_library::series_product(series_of_numbers);
            result = if trial > result { trial } else { result }
        }
        result.to_string()

    }

}

/// <summary>
/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
/// By starting with 1 and 2, the first 10 terms will be:
///     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
/// find the sum of the even-valued terms.
/// </summary>
/// <returns></returns>
pub mod even_fibonacci {

    pub fn compute() -> String {
        let mut result = 2;
        let mut term1 = 1;
        let mut term2 = 2;

        let mut sum = term1 + term2;
        while sum < 4000000 {
            if ::euler_library::math_library::is_multiple(sum, 2) { result = result + sum; }
            term1 = term2;
            term2 = sum;
            sum = term1 + term2;
        };

        result.to_string()
    }

}

/// <summary>
/// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
/// Find the largest palindrome made from the product of two 3-digit numbers
/// </summary>
/// <returns></returns>
pub mod largest_palindrome_product {
    pub fn compute() -> String {
        let mut result: u64 = 0;
        for number1 in 100..1000 {
            for number2 in number1..1000 {
                let product: u64 = number1 * number2;
                let string_version = product.to_string();
                if &string_version[0..1] == &string_version[string_version.chars().count()-1..] {
                    if ::euler_library::math_library::reverse_digits(product) == product && product > result {
                        result = product;
                    }
                }
            }
        }
        result.to_string()
    }
}

/// <summary>
/// The prime factors of 13195 are 5, 7, 13 and 29.
/// What is the largest prime factor of the number 600,851,475,143?
/// </summary>
/// <returns></returns>
pub mod largest_prime_factor {
    pub fn compute() -> String {
        let value = 600851475143;
        let factors: Vec<u64> = ::euler_library::math_library::get_factors_for(value);
        let result = factors[factors.len() - 1]; 
        result.to_string()
    }
}

pub mod prime10001 {
    pub fn compute() -> String {
        let prime_numbers = ::euler_library::math_library::get_prime(110000);
        let result: u64 = prime_numbers[10001 - 1];
        result.to_string()
    }
}


/// <summary>
/// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
/// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
/// </summary>
/// <returns></returns>
pub mod smallest_multiple {
    pub fn compute() -> String {

        fn all_are_factors(n: u64, trial: u64) -> bool {
            if n == 1 { true }
            else if !(::euler_library::math_library::is_multiple(trial, n)) { false }
            else { all_are_factors(n - 1, trial) }
        }

        fn find_solution(n: u64, trial: u64) -> u64 {
            let mut result = trial;
            while !all_are_factors(n, result) { result = result + trial }
            result
        }

        let n: u64 = 30;
        let primes = ::euler_library::math_library::get_prime(n);
        let mut gap = 1;
        for prime in primes { gap = gap * prime; }
        let result = find_solution(n, gap);
        result.to_string()
    }
}

pub mod sum_square_difference{
    pub fn compute() -> String {
        (::euler_library::math_library::square(::euler_library::math_library::sum_natural(100)) - ::euler_library::math_library::sum_natural_squares(100)).to_string()
    }
}